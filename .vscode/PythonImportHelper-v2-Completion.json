[
    {
        "label": "ply.lex",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ply.lex",
        "description": "ply.lex",
        "detail": "ply.lex",
        "documentation": {}
    },
    {
        "label": "cupy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cupy",
        "description": "cupy",
        "detail": "cupy",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "yacc",
        "importPath": "ply",
        "description": "ply",
        "isExtraImport": true,
        "detail": "ply",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "parsing_lex",
        "description": "parsing_lex",
        "isExtraImport": true,
        "detail": "parsing_lex",
        "documentation": {}
    },
    {
        "label": "MyLexer",
        "importPath": "parsing_lex",
        "description": "parsing_lex",
        "isExtraImport": true,
        "detail": "parsing_lex",
        "documentation": {}
    },
    {
        "label": "MyLexer",
        "kind": 6,
        "importPath": "parsing_lex",
        "description": "parsing_lex",
        "peekOfCode": "class MyLexer(object):\n    # This is the class that will build the Lexer \n    # Let's have our Lexer handle reserved keywords \n    reserved = {\n        'if': 'IF',\n        'else': 'ELSE',\n        'elif': 'ELIF',\n        'while': 'WHILE',\n        'for': 'FOR',\n        'in': 'IN',",
        "detail": "parsing_lex",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "parsing_lex",
        "description": "parsing_lex",
        "peekOfCode": "def main(input):\n    # Call your parsing function(s) here\n    # Let input be a string that contains the code to be parsed \n    m = MyLexer() \n    m.build() \n    m.test(input)\nif __name__ == \"__main__\":\n    main()",
        "detail": "parsing_lex",
        "documentation": {}
    },
    {
        "label": "add_with_gpu",
        "kind": 2,
        "importPath": "pythonTopython",
        "description": "pythonTopython",
        "peekOfCode": "def add_with_gpu(self, x_np, y_np):\n    \"\"\"\n    perform element-wise addition of two arrays using GPU acceleration\n    parameters:\n    x_np (numpy.ndarray): The first input array\n    y_np (numpy.ndarray): The second input array\n    returns:\n    numpy.ndarray: The result of adding x_np and y_np element-wise, returned as a NumPy array\n    sample usage: \n        x_np = np.array([5, 7, 9])",
        "detail": "pythonTopython",
        "documentation": {}
    },
    {
        "label": "subtract_with_gpu",
        "kind": 2,
        "importPath": "pythonTopython",
        "description": "pythonTopython",
        "peekOfCode": "def subtract_with_gpu(self, x_np, y_np):\n    \"\"\"\n    perform element-wise subtraction of two arrays using GPU acceleration\n    parameters:\n    x_np (numpy.ndarray): The minuend array\n    y_np (numpy.ndarray): The subtrahend array\n    returns:\n    numpy.ndarray: The result of subtracting y_np from x_np element-wise, returned as a NumPy array\n    sample usage: \n        x_np = np.array([5, 7, 9])",
        "detail": "pythonTopython",
        "documentation": {}
    },
    {
        "label": "sum_with_gpu",
        "kind": 2,
        "importPath": "pythonTopython",
        "description": "pythonTopython",
        "peekOfCode": "def sum_with_gpu(a_np, axis=None, dtype=None, keepdims=False):\n    \"\"\"\n    compute the sum of array elements over a given axis using GPU acceleration\n    parameters:\n        - a_np (numpy.ndarray): The input array.\n        - axis (int or tuple of ints, optional): Axis or axes along which a sum is performed. Default is None, summing all elements\n        - dtype (data-type, optional): The type of the returned array and of the accumulator in which the elements are summed\n        - keepdims (bool, optional): If this is set to True, the axes which are reduced are left in the result as dimensions with size one\n    returns:\n        - numpy.ndarray: An array with the same shape as `a_np`, except the axis along which the sum is computed is removed, unless `keepdims` is True",
        "detail": "pythonTopython",
        "documentation": {}
    },
    {
        "label": "dot_with_gpu",
        "kind": 2,
        "importPath": "pythonTopython",
        "description": "pythonTopython",
        "peekOfCode": "def dot_with_gpu(a_np, b_np):\n    \"\"\"\n    compute the dot product of two arrays using GPU acceleration.\n    parameters:\n        - a_np (numpy.ndarray): First operand, can be a 1-D or 2-D array.\n        - b_np (numpy.ndarray): Second operand, must be a 1-D or 2-D array.\n    returns:\n        - numpy.ndarray: Dot product of a_np and b_np. If both a_np and b_np are 1-D arrays, it returns the inner product. If both are 2-D, it returns the matrix product.\n    sample usage:\n        a_np = np.array([1, 2])",
        "detail": "pythonTopython",
        "documentation": {}
    },
    {
        "label": "function_caller",
        "kind": 2,
        "importPath": "pythonTopython",
        "description": "pythonTopython",
        "peekOfCode": "def function_caller(func_name, params):\n    \"\"\"\n    dynamically call a function based on the provided name and parameters (from the parser's output)\n    parameters:\n        - func_name (str): The name of the function to be called\n        - params (list): A list of parameters to be passed to the function\n    returns:\n        - the result of the function call\n    sample usage:\n        result = function_caller('add', [np.array([1, 2, 3]), np.array([4, 5, 6])])",
        "detail": "pythonTopython",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "pythonTopython",
        "description": "pythonTopython",
        "peekOfCode": "def main():\n    # Your main code logic goes here\n    pass\nif __name__ == \"__main__\":\n    main()",
        "detail": "pythonTopython",
        "documentation": {}
    },
    {
        "label": "set_u",
        "kind": 2,
        "importPath": "pythonToC",
        "description": "pythonToC",
        "peekOfCode": "def set_up (args, file_name):\n    file = open(file_name + \".c\", \"a\")\n    file.write(\"#include <stdio.h>\\n\")\n    file.write(\"#include <cuda_runtime.h>\\n\\n\")\n    file.write(\"__global__ void \" + file_name + \"(int [][] args) {\\n\")\n    # parse through the function\n    file.write(\"}\\n\\n__host__\\n\")\n    file.write(\"int main() {\\n\")\n    file.write(\"const int THREADS_PER_BLOCK = 256, BLOCKS = 3;\\n\\n\")\n    # convert args to c",
        "detail": "pythonToC",
        "documentation": {}
    },
    {
        "label": "args_to_c",
        "kind": 2,
        "importPath": "pythonToC",
        "description": "pythonToC",
        "peekOfCode": "def args_to_c():\n    #convert python args to c\n    #numpy\ndef main():\n    pass\nif __name__ == \"__main__\":\n    main()\n#helper functions\n__device__ void addArraysHelper(float *array1, float *array2, float *result) {\n    int N = blockDim.x * gridDim.x;",
        "detail": "pythonToC",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "pythonToC",
        "description": "pythonToC",
        "peekOfCode": "def main():\n    pass\nif __name__ == \"__main__\":\n    main()\n#helper functions\n__device__ void addArraysHelper(float *array1, float *array2, float *result) {\n    int N = blockDim.x * gridDim.x;\n    for (int i = threadIdx.x + blockIdx.x * blockDim.x; i < N; i += blockDim.x * gridDim.x) {\n        result[i] = array1[i] + array2[i];\n    }",
        "detail": "pythonToC",
        "documentation": {}
    },
    {
        "label": "MyParser",
        "kind": 6,
        "importPath": "parsing_yacc",
        "description": "parsing_yacc",
        "peekOfCode": "class MyParser(object): \n    # Define the tokens that the parser will recognize \n    tokens = MyLexer.tokens\n    # Handle print statements \n    def p_print_statement(self, p):\n        '''statement : PRINT LPAREN STRING RPAREN'''\n        # Based on the mode, we either want to call the C or Python print function \n        if self.mode == 'C':\n            # return a print statement in C \n            output = \"printf(%s);\" % p[3] ",
        "detail": "parsing_yacc",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "parsing_yacc",
        "description": "parsing_yacc",
        "peekOfCode": "def main(input, mode):\n    # Create a parser object\n    parser = MyParser(mode)\n    # Parse the input\n    return parser.parse(input)\nif __name__ == '__main__':\n    main()",
        "detail": "parsing_yacc",
        "documentation": {}
    },
    {
        "label": "_tabversion",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_tabversion = '3.10'\n_lr_method = 'LALR'\n_lr_signature = 'COLON COMMENT DEF DIVIDE DOUBLE_EQUALS ELIF ELSE EQUALS FALSE FOR IF IN LPAREN MINUS NONE NUMBER PLUS PRINT RANGE RETURN RPAREN STRING TIMES TRUE WHILEstatement : PRINT LPAREN STRING RPARENstatement : NUMBER PLUS NUMBERstatement : NUMBER MINUS NUMBERstatement : NUMBER TIMES NUMBERstatement : NUMBER DIVIDE NUMBERstatement : LPAREN statement RPAREN'\n_lr_action_items = {'PRINT':([0,3,],[2,2,]),'NUMBER':([0,3,7,8,9,10,],[4,4,13,14,15,16,]),'LPAREN':([0,2,3,],[3,5,3,]),'$end':([1,12,13,14,15,16,17,],[0,-6,-2,-3,-4,-5,-1,]),'PLUS':([4,],[7,]),'MINUS':([4,],[8,]),'TIMES':([4,],[9,]),'DIVIDE':([4,],[10,]),'STRING':([5,],[11,]),'RPAREN':([6,11,12,13,14,15,16,17,],[12,17,-6,-2,-3,-4,-5,-1,]),}\n_lr_action = {}\nfor _k, _v in _lr_action_items.items():\n   for _x,_y in zip(_v[0],_v[1]):\n      if not _x in _lr_action:  _lr_action[_x] = {}\n      _lr_action[_x][_k] = _y\ndel _lr_action_items",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_method",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_method = 'LALR'\n_lr_signature = 'COLON COMMENT DEF DIVIDE DOUBLE_EQUALS ELIF ELSE EQUALS FALSE FOR IF IN LPAREN MINUS NONE NUMBER PLUS PRINT RANGE RETURN RPAREN STRING TIMES TRUE WHILEstatement : PRINT LPAREN STRING RPARENstatement : NUMBER PLUS NUMBERstatement : NUMBER MINUS NUMBERstatement : NUMBER TIMES NUMBERstatement : NUMBER DIVIDE NUMBERstatement : LPAREN statement RPAREN'\n_lr_action_items = {'PRINT':([0,3,],[2,2,]),'NUMBER':([0,3,7,8,9,10,],[4,4,13,14,15,16,]),'LPAREN':([0,2,3,],[3,5,3,]),'$end':([1,12,13,14,15,16,17,],[0,-6,-2,-3,-4,-5,-1,]),'PLUS':([4,],[7,]),'MINUS':([4,],[8,]),'TIMES':([4,],[9,]),'DIVIDE':([4,],[10,]),'STRING':([5,],[11,]),'RPAREN':([6,11,12,13,14,15,16,17,],[12,17,-6,-2,-3,-4,-5,-1,]),}\n_lr_action = {}\nfor _k, _v in _lr_action_items.items():\n   for _x,_y in zip(_v[0],_v[1]):\n      if not _x in _lr_action:  _lr_action[_x] = {}\n      _lr_action[_x][_k] = _y\ndel _lr_action_items\n_lr_goto_items = {'statement':([0,3,],[1,6,]),}",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_signature",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_signature = 'COLON COMMENT DEF DIVIDE DOUBLE_EQUALS ELIF ELSE EQUALS FALSE FOR IF IN LPAREN MINUS NONE NUMBER PLUS PRINT RANGE RETURN RPAREN STRING TIMES TRUE WHILEstatement : PRINT LPAREN STRING RPARENstatement : NUMBER PLUS NUMBERstatement : NUMBER MINUS NUMBERstatement : NUMBER TIMES NUMBERstatement : NUMBER DIVIDE NUMBERstatement : LPAREN statement RPAREN'\n_lr_action_items = {'PRINT':([0,3,],[2,2,]),'NUMBER':([0,3,7,8,9,10,],[4,4,13,14,15,16,]),'LPAREN':([0,2,3,],[3,5,3,]),'$end':([1,12,13,14,15,16,17,],[0,-6,-2,-3,-4,-5,-1,]),'PLUS':([4,],[7,]),'MINUS':([4,],[8,]),'TIMES':([4,],[9,]),'DIVIDE':([4,],[10,]),'STRING':([5,],[11,]),'RPAREN':([6,11,12,13,14,15,16,17,],[12,17,-6,-2,-3,-4,-5,-1,]),}\n_lr_action = {}\nfor _k, _v in _lr_action_items.items():\n   for _x,_y in zip(_v[0],_v[1]):\n      if not _x in _lr_action:  _lr_action[_x] = {}\n      _lr_action[_x][_k] = _y\ndel _lr_action_items\n_lr_goto_items = {'statement':([0,3,],[1,6,]),}\n_lr_goto = {}",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_action_items",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_action_items = {'PRINT':([0,3,],[2,2,]),'NUMBER':([0,3,7,8,9,10,],[4,4,13,14,15,16,]),'LPAREN':([0,2,3,],[3,5,3,]),'$end':([1,12,13,14,15,16,17,],[0,-6,-2,-3,-4,-5,-1,]),'PLUS':([4,],[7,]),'MINUS':([4,],[8,]),'TIMES':([4,],[9,]),'DIVIDE':([4,],[10,]),'STRING':([5,],[11,]),'RPAREN':([6,11,12,13,14,15,16,17,],[12,17,-6,-2,-3,-4,-5,-1,]),}\n_lr_action = {}\nfor _k, _v in _lr_action_items.items():\n   for _x,_y in zip(_v[0],_v[1]):\n      if not _x in _lr_action:  _lr_action[_x] = {}\n      _lr_action[_x][_k] = _y\ndel _lr_action_items\n_lr_goto_items = {'statement':([0,3,],[1,6,]),}\n_lr_goto = {}\nfor _k, _v in _lr_goto_items.items():",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_action",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_action = {}\nfor _k, _v in _lr_action_items.items():\n   for _x,_y in zip(_v[0],_v[1]):\n      if not _x in _lr_action:  _lr_action[_x] = {}\n      _lr_action[_x][_k] = _y\ndel _lr_action_items\n_lr_goto_items = {'statement':([0,3,],[1,6,]),}\n_lr_goto = {}\nfor _k, _v in _lr_goto_items.items():\n   for _x, _y in zip(_v[0], _v[1]):",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_goto_items",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_goto_items = {'statement':([0,3,],[1,6,]),}\n_lr_goto = {}\nfor _k, _v in _lr_goto_items.items():\n   for _x, _y in zip(_v[0], _v[1]):\n       if not _x in _lr_goto: _lr_goto[_x] = {}\n       _lr_goto[_x][_k] = _y\ndel _lr_goto_items\n_lr_productions = [\n  (\"S' -> statement\",\"S'\",1,None,None,None),\n  ('statement -> PRINT LPAREN STRING RPAREN','statement',4,'p_print_statement','parsing_yacc.py',14),",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_goto",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_goto = {}\nfor _k, _v in _lr_goto_items.items():\n   for _x, _y in zip(_v[0], _v[1]):\n       if not _x in _lr_goto: _lr_goto[_x] = {}\n       _lr_goto[_x][_k] = _y\ndel _lr_goto_items\n_lr_productions = [\n  (\"S' -> statement\",\"S'\",1,None,None,None),\n  ('statement -> PRINT LPAREN STRING RPAREN','statement',4,'p_print_statement','parsing_yacc.py',14),\n  ('statement -> NUMBER PLUS NUMBER','statement',3,'p_expression_plus','parsing_yacc.py',31),",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_productions",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_productions = [\n  (\"S' -> statement\",\"S'\",1,None,None,None),\n  ('statement -> PRINT LPAREN STRING RPAREN','statement',4,'p_print_statement','parsing_yacc.py',14),\n  ('statement -> NUMBER PLUS NUMBER','statement',3,'p_expression_plus','parsing_yacc.py',31),\n  ('statement -> NUMBER MINUS NUMBER','statement',3,'p_expression_minus','parsing_yacc.py',39),\n  ('statement -> NUMBER TIMES NUMBER','statement',3,'p_expression_times','parsing_yacc.py',45),\n  ('statement -> NUMBER DIVIDE NUMBER','statement',3,'p_expression_divide','parsing_yacc.py',51),\n  ('statement -> LPAREN statement RPAREN','statement',3,'p_expression_parenthesis','parsing_yacc.py',57),\n]",
        "detail": "parsetab",
        "documentation": {}
    }
]