[
    {
        "label": "ply.lex",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ply.lex",
        "description": "ply.lex",
        "detail": "ply.lex",
        "documentation": {}
    },
    {
        "label": "cupy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cupy",
        "description": "cupy",
        "detail": "cupy",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "yacc",
        "importPath": "ply",
        "description": "ply",
        "isExtraImport": true,
        "detail": "ply",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "parsing_lex",
        "description": "parsing_lex",
        "isExtraImport": true,
        "detail": "parsing_lex",
        "documentation": {}
    },
    {
        "label": "MyLexer",
        "importPath": "parsing_lex",
        "description": "parsing_lex",
        "isExtraImport": true,
        "detail": "parsing_lex",
        "documentation": {}
    },
    {
        "label": "MyLexer",
        "kind": 6,
        "importPath": "parsing_lex",
        "description": "parsing_lex",
        "peekOfCode": "class MyLexer(object):\n    # This is the class that will build the Lexer \n    # Let's have our Lexer handle reserved keywords \n    reserved = {\n        'if': 'IF',\n        'else': 'ELSE',\n        'elif': 'ELIF',\n        'while': 'WHILE',\n        'for': 'FOR',\n        'in': 'IN',",
        "detail": "parsing_lex",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "parsing_lex",
        "description": "parsing_lex",
        "peekOfCode": "def main(input):\n    # Call your parsing function(s) here\n    # Let input be a string that contains the code to be parsed \n    m = MyLexer() \n    m.build() \n    m.test(input)\nif __name__ == \"__main__\":\n    main()",
        "detail": "parsing_lex",
        "documentation": {}
    },
    {
        "label": "add_with_gpu",
        "kind": 2,
        "importPath": "pythonTopython",
        "description": "pythonTopython",
        "peekOfCode": "def add_with_gpu(self, x_np, y_np):\n    \"\"\"\n    perform element-wise addition of two arrays using GPU acceleration\n    parameters:\n    x_np (numpy.ndarray): The first input array\n    y_np (numpy.ndarray): The second input array\n    returns:\n    numpy.ndarray: The result of adding x_np and y_np element-wise, returned as a NumPy array\n    sample usage: \n        x_np = np.array([5, 7, 9])",
        "detail": "pythonTopython",
        "documentation": {}
    },
    {
        "label": "subtract_with_gpu",
        "kind": 2,
        "importPath": "pythonTopython",
        "description": "pythonTopython",
        "peekOfCode": "def subtract_with_gpu(self, x_np, y_np):\n    \"\"\"\n    perform element-wise subtraction of two arrays using GPU acceleration\n    parameters:\n    x_np (numpy.ndarray): The minuend array\n    y_np (numpy.ndarray): The subtrahend array\n    returns:\n    numpy.ndarray: The result of subtracting y_np from x_np element-wise, returned as a NumPy array\n    sample usage: \n        x_np = np.array([5, 7, 9])",
        "detail": "pythonTopython",
        "documentation": {}
    },
    {
        "label": "sum_with_gpu",
        "kind": 2,
        "importPath": "pythonTopython",
        "description": "pythonTopython",
        "peekOfCode": "def sum_with_gpu(a_np, axis=None, dtype=None, keepdims=False):\n    \"\"\"\n    compute the sum of array elements over a given axis using GPU acceleration\n    parameters:\n        - a_np (numpy.ndarray): The input array.\n        - axis (int or tuple of ints, optional): Axis or axes along which a sum is performed. Default is None, summing all elements\n        - dtype (data-type, optional): The type of the returned array and of the accumulator in which the elements are summed\n        - keepdims (bool, optional): If this is set to True, the axes which are reduced are left in the result as dimensions with size one\n    returns:\n        - numpy.ndarray: An array with the same shape as `a_np`, except the axis along which the sum is computed is removed, unless `keepdims` is True",
        "detail": "pythonTopython",
        "documentation": {}
    },
    {
        "label": "dot_with_gpu",
        "kind": 2,
        "importPath": "pythonTopython",
        "description": "pythonTopython",
        "peekOfCode": "def dot_with_gpu(a_np, b_np):\n    \"\"\"\n    compute the dot product of two arrays using GPU acceleration.\n    parameters:\n        - a_np (numpy.ndarray): First operand, can be a 1-D or 2-D array.\n        - b_np (numpy.ndarray): Second operand, must be a 1-D or 2-D array.\n    returns:\n        - numpy.ndarray: Dot product of a_np and b_np. If both a_np and b_np are 1-D arrays, it returns the inner product. If both are 2-D, it returns the matrix product.\n    sample usage:\n        a_np = np.array([1, 2])",
        "detail": "pythonTopython",
        "documentation": {}
    },
    {
        "label": "function_caller",
        "kind": 2,
        "importPath": "pythonTopython",
        "description": "pythonTopython",
        "peekOfCode": "def function_caller(func_name, params):\n    \"\"\"\n    dynamically call a function based on the provided name and parameters (from the parser's output)\n    parameters:\n        - func_name (str): The name of the function to be called\n        - params (list): A list of parameters to be passed to the function\n    returns:\n        - the result of the function call\n    sample usage:\n        result = function_caller('add', [np.array([1, 2, 3]), np.array([4, 5, 6])])",
        "detail": "pythonTopython",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "pythonTopython",
        "description": "pythonTopython",
        "peekOfCode": "def main():\n    # Your main code logic goes here\n    pass\nif __name__ == \"__main__\":\n    main()",
        "detail": "pythonTopython",
        "documentation": {}
    },
    {
        "label": "set_u",
        "kind": 2,
        "importPath": "pythonToC",
        "description": "pythonToC",
        "peekOfCode": "def set_up (args, file_name):\n    file = open(file_name + \".c\", \"a\")\n    file.write(\"#include <stdio.h>\\n\")\n    file.write(\"#include <cuda_runtime.h>\\n\\n\")\n    file.write(\"__global__ void \" + file_name + \"(int [][] args) {\\n\")\n    # parse through the function\n    file.write(\"}\\n\\n__host__\\n\")\n    file.write(\"int main() {\\n\")\n    file.write(\"const int THREADS_PER_BLOCK = 256, BLOCKS = 3;\\n\\n\")\n    # convert args to c",
        "detail": "pythonToC",
        "documentation": {}
    },
    {
        "label": "args_to_c",
        "kind": 2,
        "importPath": "pythonToC",
        "description": "pythonToC",
        "peekOfCode": "def args_to_c():\n    #convert python args to c\n    #numpy\ndef main():\n    pass\nif __name__ == \"__main__\":\n    main()\n#helper functions\n__device__ void addArraysHelper(float *array1, float *array2, float *result) {\n    int N = blockDim.x * gridDim.x;",
        "detail": "pythonToC",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "pythonToC",
        "description": "pythonToC",
        "peekOfCode": "def main():\n    pass\nif __name__ == \"__main__\":\n    main()\n#helper functions\n__device__ void addArraysHelper(float *array1, float *array2, float *result) {\n    int N = blockDim.x * gridDim.x;\n    for (int i = threadIdx.x + blockIdx.x * blockDim.x; i < N; i += blockDim.x * gridDim.x) {\n        result[i] = array1[i] + array2[i];\n    }",
        "detail": "pythonToC",
        "documentation": {}
    },
    {
        "label": "MyParser",
        "kind": 6,
        "importPath": "parsing_yacc",
        "description": "parsing_yacc",
        "peekOfCode": "class MyParser(object): \n    # Define the tokens that the parser will recognize \n    tokens = MyLexer.tokens\n    # Handle print statements \n    def p_print_statement(self, p):\n        '''statement : PRINT LPAREN STRING RPAREN \n                     | PRINT LPAREN NUMBER RPAREN\n                     | PRINT LPAREN statement RPAREN'''\n        # Based on the mode, we either want to call the C or Python print function \n        if self.mode == 'C':",
        "detail": "parsing_yacc",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "parsing_yacc",
        "description": "parsing_yacc",
        "peekOfCode": "def main(input, mode):\n    # Create a parser object\n    parser = MyParser(mode)\n    # Parse the input\n    return parser.parse(input)\nif __name__ == '__main__':\n    main()",
        "detail": "parsing_yacc",
        "documentation": {}
    },
    {
        "label": "_tabversion",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_tabversion = '3.10'\n_lr_method = 'LALR'\n_lr_signature = 'COLON COMMENT DEF DIVIDE DOUBLE_EQUALS ELIF ELSE EQUALS FALSE FOR IF IN LPAREN MINUS NONE NUMBER PLUS PRINT RANGE RETURN RPAREN STRING TIMES TRUE WHILEstatement : PRINT LPAREN STRING RPAREN \\n                     | PRINT LPAREN NUMBER RPAREN\\n                     | PRINT LPAREN statement RPARENstatement : NUMBER PLUS NUMBER \\n                     | statement PLUS NUMBER\\n                     | NUMBER PLUS statement\\n                     | statement PLUS statementstatement : NUMBER MINUS NUMBER \\n                     | statement MINUS NUMBER\\n                     | NUMBER MINUS statement\\n                     | statement MINUS statementstatement : NUMBER TIMES NUMBER \\n                     | statement TIMES NUMBER\\n                     | NUMBER TIMES statement\\n                     | statement TIMES statementstatement : NUMBER DIVIDE NUMBER\\n                     | statement DIVIDE NUMBER\\n                     | NUMBER DIVIDE statement\\n                     | statement DIVIDE statementstatement : LPAREN statement RPAREN'\n_lr_action_items = {'PRINT':([0,3,5,6,7,8,9,11,12,13,14,],[2,2,2,2,2,2,2,2,2,2,2,]),'NUMBER':([0,3,5,6,7,8,9,11,12,13,14,],[4,4,16,18,20,22,24,27,29,31,33,]),'LPAREN':([0,2,3,5,6,7,8,9,11,12,13,14,],[3,9,3,3,3,3,3,3,3,3,3,3,]),'$end':([1,15,16,17,18,19,20,21,22,26,27,28,29,30,31,32,33,34,35,36,37,],[0,-7,-5,-11,-9,-15,-13,-19,-17,-20,-4,-6,-8,-10,-12,-14,-16,-18,-1,-2,-3,]),'PLUS':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[5,11,5,5,11,5,11,5,11,5,11,11,5,-20,11,5,11,5,11,5,11,5,-1,-2,-3,]),'MINUS':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[6,12,6,6,12,6,12,6,12,6,12,12,6,-20,12,6,12,6,12,6,12,6,-1,-2,-3,]),'TIMES':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[7,13,7,7,13,7,13,7,13,7,13,13,7,-20,13,7,13,7,13,7,13,7,-1,-2,-3,]),'DIVIDE':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[8,14,8,8,14,8,14,8,14,8,14,14,8,-20,14,8,14,8,14,8,14,8,-1,-2,-3,]),'STRING':([9,],[23,]),'RPAREN':([10,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[26,-7,-5,-11,-9,-15,-13,-19,-17,35,36,37,-20,-4,-6,-8,-10,-12,-14,-16,-18,-1,-2,-3,]),}\n_lr_action = {}\nfor _k, _v in _lr_action_items.items():\n   for _x,_y in zip(_v[0],_v[1]):\n      if not _x in _lr_action:  _lr_action[_x] = {}\n      _lr_action[_x][_k] = _y\ndel _lr_action_items",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_method",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_method = 'LALR'\n_lr_signature = 'COLON COMMENT DEF DIVIDE DOUBLE_EQUALS ELIF ELSE EQUALS FALSE FOR IF IN LPAREN MINUS NONE NUMBER PLUS PRINT RANGE RETURN RPAREN STRING TIMES TRUE WHILEstatement : PRINT LPAREN STRING RPAREN \\n                     | PRINT LPAREN NUMBER RPAREN\\n                     | PRINT LPAREN statement RPARENstatement : NUMBER PLUS NUMBER \\n                     | statement PLUS NUMBER\\n                     | NUMBER PLUS statement\\n                     | statement PLUS statementstatement : NUMBER MINUS NUMBER \\n                     | statement MINUS NUMBER\\n                     | NUMBER MINUS statement\\n                     | statement MINUS statementstatement : NUMBER TIMES NUMBER \\n                     | statement TIMES NUMBER\\n                     | NUMBER TIMES statement\\n                     | statement TIMES statementstatement : NUMBER DIVIDE NUMBER\\n                     | statement DIVIDE NUMBER\\n                     | NUMBER DIVIDE statement\\n                     | statement DIVIDE statementstatement : LPAREN statement RPAREN'\n_lr_action_items = {'PRINT':([0,3,5,6,7,8,9,11,12,13,14,],[2,2,2,2,2,2,2,2,2,2,2,]),'NUMBER':([0,3,5,6,7,8,9,11,12,13,14,],[4,4,16,18,20,22,24,27,29,31,33,]),'LPAREN':([0,2,3,5,6,7,8,9,11,12,13,14,],[3,9,3,3,3,3,3,3,3,3,3,3,]),'$end':([1,15,16,17,18,19,20,21,22,26,27,28,29,30,31,32,33,34,35,36,37,],[0,-7,-5,-11,-9,-15,-13,-19,-17,-20,-4,-6,-8,-10,-12,-14,-16,-18,-1,-2,-3,]),'PLUS':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[5,11,5,5,11,5,11,5,11,5,11,11,5,-20,11,5,11,5,11,5,11,5,-1,-2,-3,]),'MINUS':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[6,12,6,6,12,6,12,6,12,6,12,12,6,-20,12,6,12,6,12,6,12,6,-1,-2,-3,]),'TIMES':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[7,13,7,7,13,7,13,7,13,7,13,13,7,-20,13,7,13,7,13,7,13,7,-1,-2,-3,]),'DIVIDE':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[8,14,8,8,14,8,14,8,14,8,14,14,8,-20,14,8,14,8,14,8,14,8,-1,-2,-3,]),'STRING':([9,],[23,]),'RPAREN':([10,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[26,-7,-5,-11,-9,-15,-13,-19,-17,35,36,37,-20,-4,-6,-8,-10,-12,-14,-16,-18,-1,-2,-3,]),}\n_lr_action = {}\nfor _k, _v in _lr_action_items.items():\n   for _x,_y in zip(_v[0],_v[1]):\n      if not _x in _lr_action:  _lr_action[_x] = {}\n      _lr_action[_x][_k] = _y\ndel _lr_action_items\n_lr_goto_items = {'statement':([0,3,5,6,7,8,9,11,12,13,14,],[1,10,15,17,19,21,25,28,30,32,34,]),}",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_signature",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_signature = 'COLON COMMENT DEF DIVIDE DOUBLE_EQUALS ELIF ELSE EQUALS FALSE FOR IF IN LPAREN MINUS NONE NUMBER PLUS PRINT RANGE RETURN RPAREN STRING TIMES TRUE WHILEstatement : PRINT LPAREN STRING RPAREN \\n                     | PRINT LPAREN NUMBER RPAREN\\n                     | PRINT LPAREN statement RPARENstatement : NUMBER PLUS NUMBER \\n                     | statement PLUS NUMBER\\n                     | NUMBER PLUS statement\\n                     | statement PLUS statementstatement : NUMBER MINUS NUMBER \\n                     | statement MINUS NUMBER\\n                     | NUMBER MINUS statement\\n                     | statement MINUS statementstatement : NUMBER TIMES NUMBER \\n                     | statement TIMES NUMBER\\n                     | NUMBER TIMES statement\\n                     | statement TIMES statementstatement : NUMBER DIVIDE NUMBER\\n                     | statement DIVIDE NUMBER\\n                     | NUMBER DIVIDE statement\\n                     | statement DIVIDE statementstatement : LPAREN statement RPAREN'\n_lr_action_items = {'PRINT':([0,3,5,6,7,8,9,11,12,13,14,],[2,2,2,2,2,2,2,2,2,2,2,]),'NUMBER':([0,3,5,6,7,8,9,11,12,13,14,],[4,4,16,18,20,22,24,27,29,31,33,]),'LPAREN':([0,2,3,5,6,7,8,9,11,12,13,14,],[3,9,3,3,3,3,3,3,3,3,3,3,]),'$end':([1,15,16,17,18,19,20,21,22,26,27,28,29,30,31,32,33,34,35,36,37,],[0,-7,-5,-11,-9,-15,-13,-19,-17,-20,-4,-6,-8,-10,-12,-14,-16,-18,-1,-2,-3,]),'PLUS':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[5,11,5,5,11,5,11,5,11,5,11,11,5,-20,11,5,11,5,11,5,11,5,-1,-2,-3,]),'MINUS':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[6,12,6,6,12,6,12,6,12,6,12,12,6,-20,12,6,12,6,12,6,12,6,-1,-2,-3,]),'TIMES':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[7,13,7,7,13,7,13,7,13,7,13,13,7,-20,13,7,13,7,13,7,13,7,-1,-2,-3,]),'DIVIDE':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[8,14,8,8,14,8,14,8,14,8,14,14,8,-20,14,8,14,8,14,8,14,8,-1,-2,-3,]),'STRING':([9,],[23,]),'RPAREN':([10,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[26,-7,-5,-11,-9,-15,-13,-19,-17,35,36,37,-20,-4,-6,-8,-10,-12,-14,-16,-18,-1,-2,-3,]),}\n_lr_action = {}\nfor _k, _v in _lr_action_items.items():\n   for _x,_y in zip(_v[0],_v[1]):\n      if not _x in _lr_action:  _lr_action[_x] = {}\n      _lr_action[_x][_k] = _y\ndel _lr_action_items\n_lr_goto_items = {'statement':([0,3,5,6,7,8,9,11,12,13,14,],[1,10,15,17,19,21,25,28,30,32,34,]),}\n_lr_goto = {}",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_action_items",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_action_items = {'PRINT':([0,3,5,6,7,8,9,11,12,13,14,],[2,2,2,2,2,2,2,2,2,2,2,]),'NUMBER':([0,3,5,6,7,8,9,11,12,13,14,],[4,4,16,18,20,22,24,27,29,31,33,]),'LPAREN':([0,2,3,5,6,7,8,9,11,12,13,14,],[3,9,3,3,3,3,3,3,3,3,3,3,]),'$end':([1,15,16,17,18,19,20,21,22,26,27,28,29,30,31,32,33,34,35,36,37,],[0,-7,-5,-11,-9,-15,-13,-19,-17,-20,-4,-6,-8,-10,-12,-14,-16,-18,-1,-2,-3,]),'PLUS':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[5,11,5,5,11,5,11,5,11,5,11,11,5,-20,11,5,11,5,11,5,11,5,-1,-2,-3,]),'MINUS':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[6,12,6,6,12,6,12,6,12,6,12,12,6,-20,12,6,12,6,12,6,12,6,-1,-2,-3,]),'TIMES':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[7,13,7,7,13,7,13,7,13,7,13,13,7,-20,13,7,13,7,13,7,13,7,-1,-2,-3,]),'DIVIDE':([1,4,10,15,16,17,18,19,20,21,22,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[8,14,8,8,14,8,14,8,14,8,14,14,8,-20,14,8,14,8,14,8,14,8,-1,-2,-3,]),'STRING':([9,],[23,]),'RPAREN':([10,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,],[26,-7,-5,-11,-9,-15,-13,-19,-17,35,36,37,-20,-4,-6,-8,-10,-12,-14,-16,-18,-1,-2,-3,]),}\n_lr_action = {}\nfor _k, _v in _lr_action_items.items():\n   for _x,_y in zip(_v[0],_v[1]):\n      if not _x in _lr_action:  _lr_action[_x] = {}\n      _lr_action[_x][_k] = _y\ndel _lr_action_items\n_lr_goto_items = {'statement':([0,3,5,6,7,8,9,11,12,13,14,],[1,10,15,17,19,21,25,28,30,32,34,]),}\n_lr_goto = {}\nfor _k, _v in _lr_goto_items.items():",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_action",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_action = {}\nfor _k, _v in _lr_action_items.items():\n   for _x,_y in zip(_v[0],_v[1]):\n      if not _x in _lr_action:  _lr_action[_x] = {}\n      _lr_action[_x][_k] = _y\ndel _lr_action_items\n_lr_goto_items = {'statement':([0,3,5,6,7,8,9,11,12,13,14,],[1,10,15,17,19,21,25,28,30,32,34,]),}\n_lr_goto = {}\nfor _k, _v in _lr_goto_items.items():\n   for _x, _y in zip(_v[0], _v[1]):",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_goto_items",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_goto_items = {'statement':([0,3,5,6,7,8,9,11,12,13,14,],[1,10,15,17,19,21,25,28,30,32,34,]),}\n_lr_goto = {}\nfor _k, _v in _lr_goto_items.items():\n   for _x, _y in zip(_v[0], _v[1]):\n       if not _x in _lr_goto: _lr_goto[_x] = {}\n       _lr_goto[_x][_k] = _y\ndel _lr_goto_items\n_lr_productions = [\n  (\"S' -> statement\",\"S'\",1,None,None,None),\n  ('statement -> PRINT LPAREN STRING RPAREN','statement',4,'p_print_statement','parsing_yacc.py',14),",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_goto",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_goto = {}\nfor _k, _v in _lr_goto_items.items():\n   for _x, _y in zip(_v[0], _v[1]):\n       if not _x in _lr_goto: _lr_goto[_x] = {}\n       _lr_goto[_x][_k] = _y\ndel _lr_goto_items\n_lr_productions = [\n  (\"S' -> statement\",\"S'\",1,None,None,None),\n  ('statement -> PRINT LPAREN STRING RPAREN','statement',4,'p_print_statement','parsing_yacc.py',14),\n  ('statement -> PRINT LPAREN NUMBER RPAREN','statement',4,'p_print_statement','parsing_yacc.py',15),",
        "detail": "parsetab",
        "documentation": {}
    },
    {
        "label": "_lr_productions",
        "kind": 5,
        "importPath": "parsetab",
        "description": "parsetab",
        "peekOfCode": "_lr_productions = [\n  (\"S' -> statement\",\"S'\",1,None,None,None),\n  ('statement -> PRINT LPAREN STRING RPAREN','statement',4,'p_print_statement','parsing_yacc.py',14),\n  ('statement -> PRINT LPAREN NUMBER RPAREN','statement',4,'p_print_statement','parsing_yacc.py',15),\n  ('statement -> PRINT LPAREN statement RPAREN','statement',4,'p_print_statement','parsing_yacc.py',16),\n  ('statement -> NUMBER PLUS NUMBER','statement',3,'p_expression_plus','parsing_yacc.py',33),\n  ('statement -> statement PLUS NUMBER','statement',3,'p_expression_plus','parsing_yacc.py',34),\n  ('statement -> NUMBER PLUS statement','statement',3,'p_expression_plus','parsing_yacc.py',35),\n  ('statement -> statement PLUS statement','statement',3,'p_expression_plus','parsing_yacc.py',36),\n  ('statement -> NUMBER MINUS NUMBER','statement',3,'p_expression_minus','parsing_yacc.py',44),",
        "detail": "parsetab",
        "documentation": {}
    }
]